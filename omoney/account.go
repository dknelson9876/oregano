package omoney

import (
	"fmt"
	"sort"
	"time"

	"github.com/google/uuid"
)

type AccountType string

const (
	UnknownAccount = "unknown"
	Checking       = "checking"
	Savings        = "savings"
	CreditCard     = "creditCard"
	Investment     = "investment"
	PersonalLoan   = "personalLoan"
)

type Account struct {
	// Unique identifier for account within this program.
	// May be copied from Plaid or generated by this program.
	// Required field.
	Id string
	// English nickname for account within this program.
	// Optional field that defaults to empty string.
	Alias string
	// Plaid generated key for getting data on this account.
	// Defaults to empty string if account was manually created.
	PlaidToken   string
	Type         AccountType
	Transactions []Transaction
	// The known value of this account at the time specified
	// in `AnchorTime`. Optional field that defaults to 0
	anchorBalance float64
	// The time specified for the known value `AnchorBalance`.
	// Optional field that defaults to time.Now()
	anchorTime time.Time
	// The calculated current balance of this account
	CurrentBalance float64
	// The time at which `CurrentBalance` was last calculated
}

type AccountOption func(*Account)

func NewAccount(options ...AccountOption) *Account {
	acc := &Account{
		Id:           uuid.New().String(),
		Type:         UnknownAccount,
		Transactions: make([]Transaction, 0),
		anchorTime:   time.Now(),
	}

	for _, op := range options {
		op(acc)
	}

	return acc
}

func WithPlaidIds(itemId string, accessToken string) AccountOption {
	return func(acc *Account) {
		acc.Id = itemId
		acc.PlaidToken = accessToken
	}
}

func WithAlias(alias string) AccountOption {
	return func(acc *Account) {
		acc.Alias = alias
	}
}

func WithAnchor(balance float64, time time.Time) AccountOption {
	return func(acc *Account) {
		acc.anchorBalance = balance
		acc.anchorTime = time
	}
}

func WithAccountType(accType AccountType) AccountOption {
	return func(acc *Account) {
		acc.Type = accType
	}
}

func ParseAccountType(input string) (AccountType, error) {
	switch input {
	case "ch", "checking":
		return Checking, nil
	case "sa", "savings":
		return Savings, nil
	case "cc", "credit":
		return CreditCard, nil
	case "in", "investment":
		return Investment, nil
	case "pl", "personalLoan":
		return PersonalLoan, nil
	default:
		return UnknownAccount, fmt.Errorf("account type %s not recognized", input)
	}
}

func (acc *Account) SetAnchor(balance float64, time time.Time) {
	acc.anchorBalance = balance
	acc.anchorTime = time
	acc.UpdateCurrentBalance()
}

func (acc *Account) GetAnchor() (float64, time.Time) {
	return acc.anchorBalance, acc.anchorTime
}

func (acc *Account) GetAnchorBalance() float64 {
	return acc.anchorBalance
}

func (acc *Account) GetAnchorTime() time.Time {
	return acc.anchorTime
}

func (acc *Account) AddTransaction(tr Transaction) {
	acc.Transactions = append(acc.Transactions, tr)
	sort.Slice(acc.Transactions, func(i, j int) bool {
		return acc.Transactions[i].Date.After(acc.Transactions[j].Date)
	})

	acc.UpdateCurrentBalance()
}

func (acc *Account) UpdateCurrentBalance() {
	i := sort.Search(len(acc.Transactions), func (i int) bool {
		return acc.anchorTime.After(acc.Transactions[i].Date)
	})

	affectingTransactions := acc.Transactions[:i]
	fmt.Println(affectingTransactions)
	fmt.Println(i)
	bal := acc.anchorBalance
	for _, t := range affectingTransactions {
		bal += t.Amount
	}

	acc.CurrentBalance = bal
	fmt.Printf("New balance $%.2f\n", bal)
}